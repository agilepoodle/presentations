<!DOCTYPE html>
<html>
  <head>
    <title>Large Software Systems</title>
    <meta charset="utf-8">
    <style>
      @import url('assets/styles/nitor.css');
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle, title

![Nitor Logo](assets/images/nitor_logo_fi.png)

# Large Software Systems 
## The Developer Perspective

### Nitor x Aalto University 31.1.2019

???

### Please, interrupt whenever you have a question!
### This is more fun when interactive!

---

class: center, middle, title, jam

# Jussi Mononen
## 20+ years of experience in sw
## Computers since 1980's
## Not just code, also people & processes
## Telcos, financial, logistics, media, universities, gaming
## Still Curious and passionate

---

class: center, middle, title, sisu

.right[![sc-logo](./assets/images/sc.jpg)]

???

### Current project/customer, Supercell
### Previous Funidata - Sisu, almost 4 yrs
### Size: Sisu: Common business support system for 5 middle-sized listed companies
### Size: SC: Data, so much data! Webscale!

---

class: center, middle, title, software

# What is software about?

???

### This presentation tries to describe how I see the SW world
### I try to describe the things I think are important in all size SW systems
### 20 years of experience squeezed into 1,5 hours

---

class: center, middle, title, people

# People

???

### At least 50% about people
### Cross-functionality, different skill sets, biz, design, code, ...
### Large projects, large amount of people, communication paths grow exponentially
### Communication issues, Wiio's laws
### When communication fails, you build the wrong thing!
### What to do? Who benefits? Why? We need these answers!
### Software is for humans
### Programming is a technical aspect, nuance, nuisance?
### Users, customers, business owners, developers etc.
### People create SW, so we need Purpose, Autonomy, Mastery (Daniel Pink)

---

class: center, title, middle, problem

# Software is Problem solving

???

### You need to understand the problem and domain first
### Not just programming! Interactions, systems of systems
### Large projects just have more problems to solve, larger domains etc.
### Domain-Driven Design, Eric Evans - https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20
### Focus on core model, Base complex design on models, match domain experts /w programmers
### Solution oriented!
### Best software is not written
### Solve next problem, then next, ...

---

class: center, title, middle, simple

# Simple is not easy.

???

### Google for Lego manufacturing process! Material quality, precision injection molding, high automation
### No over-engineering, use the most simple solution available
### Do not make it more complex than needed "just in case", you won't need it in the future
### Simple architecture is extendable and modifiable 

---

class: center, title, middle, simple

# "Simple can be harder than complex: You have to work hard to get your thinking clean to make it simple. But itâ€™s worth it in the end because once you get there, you can move mountains." - Steve Jobs

---

class: center, title, middle, complexity

# Avoid complexity

???

### Added complexity sneaks in!
### Long projects tend to increase complexity
### Do absolute minimum that suffices
### Added complexity accrues cost!
### Rich Hickey - https://www.youtube.com/watch?v=rI8tNMsozo0
### Complex is hard to change
### Simplicity is a pre-requisite for reliability
### Intertwined things must be cosidered together - We can consider ony a few things at the same time
### You can select only few -ilities; scalability, felxibility, upgradeability, interoperability, transactionality, auditability, usability, portability, reliability, availability etc

---

class: center, middle, title, validate

# Validate your hypothesis

???

### Don't write software in vain!
### Validate your business idea - Why is software needed?
### If it is not needed, don't do it! 
### Good methods: Biz model canvas, value proposition canvas,
### Service design - design sprints
### Deliver to production!
### What is the best way to validate software? -> delivery to real users
### No software survives the first contact with the user

---

class: center, middle, title, stream

# Value Stream
# Cycle/Lead time

???

### Small batch size! -> Quick validation, forecasting
### Concentrate on value, remove waste - especially in large projects
### Question everything, is it really needed?
### Measure the time from an idea to production (whatever production means) - Make it shorter!
### Software has 4 types of value: create new value, maintain existing value, prevent value loss, recover from value loss

---

class: center, middle, title, computer

# The Only reliable metric is ?

---

class: center, middle, title, computer

# The Only reliable metric is delivered software

???

### Metrics in software: When we are ready? When the product is ready? Quality? 
### Use history to forecast into the future
### Delivery early, deliver often
### Delivered software creates a validation loop!
### If it is not delivered, it's inventory
### Real life usage can be used to validate the product
### Deliver to test env if prod not possible!
### Practice delivery!

---

class: center, title, middle, money

# Total cost of ownership

???

### 20/80 rule, 20% of features bring 80% of value
### Affects decisions during development
### Short-lived product vs long-lived
### All decisions must be done with TCO in mind!
### Maintenance, future developers
### No esoteric technologies without a good case, select the correct tool for the job

---

class: center, middle, title, fortress

# Reliability
# Robustness
# Security

???

### Extra care needed with large systems
### Can prevent usage
### Must be included in design and architecture from early on
### Cannot be attached 'after the fact' - or very costly
### Anti-fragile software
### capabilities to scale

---

class: center, middle, title, capacity

# Capacity

???

### WIP limits
### Hard prioritization
### Explicit work backlog
### Helps predicting/forecasting
### Overload developers creates stress


---

class: center, middle, title, practice

# Practices
## Architecture decision log
## Test code is production code
## Pairing (mob programming)
## Team alignment

???

### Treat tests as production code (maintenance)
### Business has value -> code is waste -> tests are toxic waste
### Best software is software that is not written
### Pairing: problems solving, learning, mentoring, sharing knowledge
### Same overall direction for everyone
### No silos (quality, design, security)

---

class: center, title, middle, thankyou

# Thank you!

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        slideNumberFormat: '<span class="presentation-date">30.10.2018</span><span class="confidential">Luottamuksellinen</span><span class="slide-number">%current%</span><span class="small-logo"><img src="assets/images/nitor_logo_small.png"/></span>',
      });
    </script>
  </body>
</html>

