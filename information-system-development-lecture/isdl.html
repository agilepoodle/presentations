<!DOCTYPE html>
<html>
  <head>
    <title>Large Software Systems</title>
    <meta charset="utf-8">
    <style>
      @import url('assets/styles/style.css');
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle, title

# Large Software Systems 
## The Developer Perspective

### CarbonLink x Aalto University 27.1.2022

???

### Please, interrupt whenever you have a question!
### This is more fun when interactive!

---

class: center, middle, title, jam

# Jussi Mononen
## 22+ years of experience in sw
## Computers since 1980's
## Not just code, also people & processes
## Telcos, financial, logistics,
## media, universities, gaming, climate
### Still Curious and passionate

---

class: center, middle, title, sisu

.right[![sc-logo](./assets/images/sc.jpg)]
.left[![carbonlink-logo](./assets/images/logo.png)]

???

### Current: CarbonLink
### Previous project/customer, Supercell, 2 yrs
### Previous^2 Funidata - Sisu, 4 yrs
### Size: Sisu: Common business support system for 5 middle-sized listed companies
### Size: SC: Data, so much data! Webscale!
### Size: CL: organization financial data

---

class: center, middle, title, software

# What is software about?

???

### This presentation tries to describe how I see the SW world
### I try to describe the things I think are important in all size SW systems
### 22+ years of experience squeezed into 1,5 hours

---

class: center, middle, title, people

# People

???

### At least 50% about people
### Cross-functionality, different skill sets, biz, design, code, abilities and limitations...
### Large projects, large amount of people, communication paths grow exponentially
### Communication issues, Wiio's laws
### When communication fails, you build the wrong thing!
### What to do? Who benefits? Why? We need these answers!
### Software is consumed by humans and other software systems
### Value of software is for humans, usually
### Programming is a technical aspect, nuance, nuisance?
### Users, customers, business owners, developers etc.
### People create SW, so we need Purpose, Autonomy, Mastery (Daniel Pink)

---

class: center, title, middle, problem

# Software is Problem solving

???

### You need to understand the problem and domain first
### Not just programming! Interactions, systems of systems
### Cascade of effects, ripple effect
### Large projects just have more problems to solve, larger domains etc.
### How to solve? One problem at a time.
### How to solve complexity?
* Domain-Driven Design, Eric Evans - https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20
* Focus on core model, base complex design on models, match domain experts /w programmers, ubiquitos language
* Solution oriented!
* Best software is not written

---

class: center, title, middle, simple

# Simple is not easy.

???

### Google for Lego manufacturing process! Material quality, precision injection molding, high automation
### No over-engineering, use the most simple solution available
### Do not make it more complex than needed "just in case", you won't need it in the future
### "Easy for you" does not equal "good for the system"
### Simple architecture is extendable and modifiable 

---

class: center, title, middle, simple

# "Simple can be harder than complex: You have to work hard to get your thinking clean to make it simple. But itâ€™s worth it in the end because once you get there, you can move mountains." - Steve Jobs

---

class: center, title, middle, complexity

# Avoid complexity

???

### Added complexity sneaks in!
### Long projects tend to increase complexity
### Do absolute minimum that suffices
### YAGNI - You Ain't Gonna Need It!
### Added complexity accrues cost!
### Rich Hickey - https://www.youtube.com/watch?v=rI8tNMsozo0
### Complex is hard to change
### Simplicity is a pre-requisite for reliability
### Intertwined things must be cosidered together - We can consider ony a few things at the same time
### You can select only few -ilities; scalability, flexibility, upgradeability, interoperability, transactionality, auditability, usability, portability, reliability, availability etc

---

class: center, middle, title, validate

# Validate your hypothesis

???

### Don't write software in vain!
### Validate your business/feature idea - Why is this needed?
### If it is not needed, don't do it! 
### Good methods: Biz model canvas, value proposition canvas, value stream mapping etc.
### Service design - design sprints
### Deliver to production!
### What is the best way to validate software? -> delivery to real users
### No software survives the first contact with the user

---

class: center, middle, title, stream

# Value Stream
# Cycle/Lead time

???

### Small batch size! -> Quick validation, forecasting
### Concentrate on value, remove waste - especially in large projects
### Question everything, is it really needed?
### Measure the time from an idea to production (whatever production means) - Make it shorter!
### Software has 4 types of value: 
* create new value
* maintain existing value
* prevent value loss
* recover from value loss

---

class: center, middle, title, computer

# M E T R I C S

---

class: center, middle, title, computer

# The Only reliable metric is _

---

class: center, middle, title, computer

# The Only reliable metric is delivered software

???

### Metrics in software: When we are ready? When the product is ready? Quality? 
### Use history to forecast into the future
### Delivery early, deliver often
### Delivered software creates a validation loop!
### If it is not delivered, it's inventory
### Real life usage can be used to validate the product
### Deliver to test env if prod not possible!
### Practice delivery!

---

class: center, title, middle, money

# Total cost of ownership

???

### 20/80 rule, 20% of features bring 80% of value
### Affects decisions during development
### Short-lived product vs long-lived
### All decisions must be done with TCO in mind!
* maintenance (technology selections, environments)
* operation costs
* availability of skilled workers
* new feature development
* change requests
* etc. 

### Maintenance, future developers
### No esoteric technologies without a good case, select the correct tool for the job

---

class: center, middle, title, fortress

# Reliability
# Robustness
# Security

???

### Extra care needed with large systems
### Can prevent usage
### Must be included in design and architecture from early on
### Cannot be attached 'after the fact' - or very costly
### Anti-fragile software
### capabilities to scale

---

class: center, middle, title, capacity

# Capacity

???

### What can be done with your current organization?
### WIP limits
### Hard prioritization
### Explicit work backlog
### Coordination efforts - back to communication
### Helps predicting/forecasting - don't give estimates!
### Overloading developers creates stress


---

class: center, middle, title, practice

# Practices
## Architecture decision log
## Test code is production code
## Pairing (mob programming)
## Team alignment

???

### Treat tests as production code (maintenance)
### Business has value -> code is waste -> tests are toxic waste
### Best software is software that is not written
### Pairing: problems solving, learning, mentoring, sharing knowledge
### Same overall direction for everyone
### No silos (quality, design, security)
### Teams of teams for coordination - back to communication
### Bounded contexts
* isolate domains if possible
* use ubiquitous language
* anti-corruptiom with interfaces

### Public backward compatible API's as means of integration

---

class: center, title, middle, thankyou

# Thank you!

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        slideNumberFormat: '<span class="presentation-date">30.10.2018</span><span class="confidential">Luottamuksellinen</span><span class="slide-number">%current%</span><span class="small-logo"><img src="assets/images/nitor_logo_small.png"/></span>',
      });
    </script>
  </body>
</html>

